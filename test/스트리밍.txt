vp8코덱으로 인코딩 된 mjr 을 기준으로 한다.
janus-pp-rec 는 야누스 예를 들어 VP8 및 VP9 프레임은 .webm 파일로만 변환 할 수있는 반면 H.264 프레임은 .mp4 파일로만 변환 할 수 있습니다. 지금은 VP8 / VP9 녹음을 .webm으로, H.264 녹음을 .mp4로, G.711 녹음을 .wav로, Opus 녹음을 .opus로, 데이터 채널 녹음을 .srt로 변환 할 수 있습니다.

따라서 후처리 기능으로 webm이 생성된걸로 간주한다.



위 그래프로 알 수 있는 것은 H시리즈 코덱이 VP시리즈 코덱보다 인코딩 할 때 cpu사용량이 높은 대신 인코딩 시간이 빠르다는 것이다.
그리고 의외로 최신의 코덱이라고 해서 무조건 빠른속도를 보여주지는 않았다.(평균 인코딩 속도는 H264>VP8>H265>VP9으로 이루어 진다.)
오히려 기존 코덱이 더 빠른 결과를 보여주었다.
각 프레임을 비교 했을 때 vp시리즈가 비트레이트 대비 h시리즈보다 화질이 좋은걸 알 수 있다.
그런데 사실 위의 차테스트자료를 참고했을 때에는 그렇게 큰 이점인가 의문이 드는 이유는 vp시리즈가 h시리즈보다 훨씬 인코딩+디코딩 시간이 오래걸리기 때문이다.
일단 1080p까지의 화질로서는 h264와 vp8도 크게 무리없이 화질이 깨지지 않고 잘 인코딩 되는걸 볼 수 있다.
그래서 추가적으로 테스트를 진행하였다.

apt-get install janus-tools

야누스 mjr 은 비디오 오디오 나중에 webm opus 로 컨버팅
https://janus.conf.meetecho.com/docs/recordings.html

audio mjr video mjr 병합.
https://stackoverflow.com/questions/28313891/how-to-combine-audio-and-video-mjr-files-to-generate-one-file
https://superuser.com/questions/277642/how-to-merge-audio-and-video-file-in-ffmpeg

mjr to mp4 post Process 
https://github.com/meetecho/janus-gateway/blob/master/postprocessing/pp-h264.c

pp-h264.c
https://janus.97kid.com/docs/group__postprocessing.html

janus-pp-rec 로 mp4파일로 포스트 프로세싱이 된 기준.



H.264 비디오가있는 WebM을 MP4로 변환
드문 경우지만 .webm 파일에는 H.264 비디오 및 Vorbis 또는 Opus 오디오 (예 : Chrome 52+ 에서 MediaRecorder API를 사용하여 생성 된 .webm 파일 )가 포함됩니다. 이러한 경우 비디오 데이터가 이미 원하는 H.264 형식이므로 다시 인코딩 할 필요가 없습니다 (CPU주기를 사용하는 동안 프로세스에서 일부 품질이 저하되므로 다시 인코딩하지 않는 것이 좋습니다). 데이터를 복사 할 것입니다.


https://it-techstory.tistory.com/4
VP9, h265고화질 압축시간 김.
VP8의 경우 아무리 비트레이트가 높아져도 혹은 낮아져도 일정 수준의 압축 후 용량이 지켜진다.
그리고 그에 따라 비트레이트가 아무리 낮아져도 화질의 선명도가 더 떨어지지 않는다.
반면 H264의 경우 비트레이트가 높아지면 계속 압축 후 용량도 높아지고 마찬가지로 낮아지면 계속 압축 후 용량이 낮아진다.
그리고 화질도 계속 떨어진다. 


압축효율은 AV01 > VP9 > AVC1 이네요
용량 대비 화질 효율은 일반적으로 MPEG-2 < Theora < WMV 9, Xvid < VP8 < H.264 < VP9 < HEVC < AV1 순이다

https://ourcodeworld.com/articles/read/1198/how-to-join-the-audio-and-video-mjr-from-a-recorded-session-of-janus-gateway-in-ubuntu-18-04

H.264 - 이 코덱은 굉장히 효율적인 압축률을 보이는 코덱으로, 동영상 제작자들의 인기를 한 몸에 받고 있다. 손실 압축 방식이지만 뛰어난 화질을 유지하며 동영상 크기를 크게 줄여주기 때문에 고화질 영상의 웹 배포용으로 특히 많이 이용된다.

H.265 - HEVC(고효율 비디오 코딩)이라고도 불리며 H.264의 업그레이드 버전이다. H.264보다 압축 효율이 2배 이상 높으며, 최근 등장한 4K 이상의 UHD 영상을 지원하도록 설계되었다.


서버 스트리밍
https://stackoverflow.com/questions/58976041/live-streaming-or-on-demand-content-hls-http-range-requests
https://javafa.gitbooks.io/nodejs_server_basic/content/chapter11.html
https://dev.to/abdisalan_js/how-to-code-a-video-streaming-server-using-nodejs-2o0
https://imkh.dev/nodejs-video-streaming-server/

https://kelog.net/playground/test/hls/

https://stackoverflow.com/questions/66700677/adaptative-bitrate-streaming-dash-hls-vs-node-streams
https://www.bsgroup.eu/what-is-the-hls-protocol-and-why-it-is-popular-in-the-streaming-industry/


리액트 비디오 플레이어
https://stackoverflow.com/questions/50594972/manage-multiple-audio-sources-in-react

비디오 스트리밍 애플리케이션을 구축하려는 경우 부분 콘텐츠를 사용하는 것이 쉬운 예일 수 있지만 제 생각에는 여러 클라이언트를 다룰 때 실제로 좋은 방법이 아닙니다. 각 클라이언트에 대해 백엔드 서비스는 비디오가 계속 요청되는 동안 클라이언트 및 파일 서버에 대한 두 개의 TCP 연결을 유지해야하며 이로 인해 높은 메모리 소비가 발생할 수 있습니다.
또한 HLS와 달리 자동 해상도의 비디오 스트리밍은 불가능합니다. HLS에는 클라이언트의 대역폭에 따라 요청할 비디오 인덱스를 결정하는 사용자 지정 JS 파일이 이미 있습니다. 부분 콘텐츠의 경우 클라이언트 측에는 특정 파일 해상도에 대해 요청 된 데이터 범위 만 제공되므로 불가능합니다.
그러나 전반적으로 소규모 애플리케이션을위한 쉬운 설정입니다.
이 기사가 도움이 되었기를 바라며 읽어 주셔서 감사합니다!

HLS 형식은 반드시 사용해야합니다. 브라우저는 필요한 실제 파일 만로드합니다. 특히 m3u8 파일의 타임 스탬프를 타임 스탬프로 지정할 수 있으므로 검색이 더 쉬워집니다. HLS는 또한 실제 비디오 세그먼트를 더 작은 청크로 분할하고 S3 / 클라우드 스토리지에 저장할 수 있습니다. hls.js 는 데스크톱 + 모바일에서 작동하는 외부 라이브러리에 대한 옵션이지만 자동 전체 화면으로 전환하는 대신 페이지에서 비디오를 결합 할 수있는 기능은 모바일 장치에 따라 달라질 수 있습니다. 미리보기 이미지에 대해해야 할 일은 해당 스트림이 타일링 된 비디오 1 개를 만든 다음 요소를 사용하여 해당 스트림을 화면에 정렬하는 것입니다. 그런 다음 필요에 따라 다양한 대형 비디오 스트림을로드 할 수 있습니다 (HLS도 가능합니다. 원하는 경우 동일한 m3u8에서 다른 레벨 일 수도 있음).


HLS vs MPEG-DASH

URL.createObjectURL blob 파일과 연동 스트리밍 서버에 적합.
http2 기반에 http3는 stream 전용으로

mediaSource.addSourceBuffer 사용시 주의사항
https://stackoverflow.com/questions/50333767/html5-video-streaming-video-with-blob-urls/50354182

비디오 레이아웃
https://tokbox.com/developer/guides/archive-broadcast-layout/

미디어 캔버스 버퍼링
https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/buffering_seeking_time_ranges

비디오 오디오 소스
https://upload.wikimedia.org/wikipedia/commons/d/d6/Louis-Emmanuel_Jadin_-_Nocturne_No._3_in_G_minor_-_2._Allegro_molto.ogg

http://media.w3.org/2010/05/video/movie_300.webm
http://media.w3.org/2010/05/sintel/trailer.mp4
https://media.w3.org/2010/05/sintel/trailer.ogv
http://www.ustream.tv/embed/recorded/81056340?html5ui 스트리밍 소스
https://bitmovin-a.akamaihd.net/content/sintel/hls/playlist.m3u8
blob:https://hls-js.netlify.app/23f649dd-5dc4-4a6a-9880-7cebdecc1853
https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8

https://ia600305.us.archive.org/30/items/return_201605/return.mp3
http://media.w3.org/2010/05/bunny/movie.ogv

https://dash.akamaized.net/akamai/bbb/bbb_1920x1080_60fps_12000k.mp4
http://media.w3.org/2010/07/bunny/04-Death_Becomes_Fur.mp4


1시간 짜리
<audio controls="" preload="true">
	<source src="https://archive.org/download/wizard-people/wiz1.ogg" type="audio/ogg">
	<source src="https://archive.org/download/wizard-people/wiz1_64kb.mp3" type="audio/mp3">
</audio>

참고
https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement

슬라이더 
https://github.com/shadowmoose/Web-Video-Editor
			var e = document.getElementById("myVideo");
var cancelAlert = false;
var run = function() {
if (e.readyState === 4 && !cancelAlert) {//readyState 4 means it is loaded fully
cancelAlert = true;//This is so that it only alerts once. No spam pls.
alert(e.duration);
}
requestAnimationFrame(run);//This is so that it runs every frame.
};
run();//run the function


완벽한 동기화를 위해 불가능합니다. 죄송합니다. 완벽한 동기화에서 1 초 단위로 이동하는 솔루션에 만족한다면

모든 JS 구현 (팝콘 포함)은 지연 문제 (즉, 동기화되지 않음)를 겪습니다. 그것은 오디오에 매우 나쁩니다. 자바 스크립트와 동기화 할 수 없습니다. 미디어 그룹이이를 수행하는 유일한 방법이며 이제는 사파리에서만 사용할 수 있습니다

동기화 할 수 없습니다. Vimeo가이 기능을 지원했다면-아마도 지원하지 않을 것이며, 사용자의 브라우저 성능과 인터넷 속도는 물론 당시의 서버 성능에 크게 좌우 될 것입니다. 사람들은 다른 비디오는 말할 것도없고 동일한 비디오에서 동기화되지 않은 오디오를 경험할 수 있습니다.

requestAnimationFrame 
그런 다음 canvas context.drawImage의 확장 된 클리핑 속성을 사용하여 각 단일 프레임을 2-3 개의 개별 프레임으로 나눌 수 있습니다.

var fs = require("fs"),
    http = require("http"),
    url = require("url"),
    path = require("path");

http.createServer(function (req, res) {
  if (req.url != "/movie.mp4") {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end('<video src="http://localhost:8888/movie.mp4" controls></video>');
  } else {
    var file = path.resolve(__dirname,"movie.mp4");
    fs.stat(file, function(err, stats) {
      if (err) {
        if (err.code === 'ENOENT') {
          // 404 Error if file not found
          return res.sendStatus(404);
        }
      res.end(err);
      }
      var range = req.headers.range;
      if (!range) {
       // 416 Wrong range
       return res.sendStatus(416);
      }
      var positions = range.replace(/bytes=/, "").split("-");
      var start = parseInt(positions[0], 10);
      var total = stats.size;
      var end = positions[1] ? parseInt(positions[1], 10) : total - 1;
      var chunksize = (end - start) + 1;

      res.writeHead(206, {
        "Content-Range": "bytes " + start + "-" + end + "/" + total,
        "Accept-Ranges": "bytes",
        "Content-Length": chunksize,
        "Content-Type": "video/mp4"
      });

      var stream = fs.createReadStream(file, { start: start, end: end })
        .on("open", function() {
          stream.pipe(res);
        }).on("error", function(err) {
          res.end(err);
        });
    });
  }
}).listen(8888);


var http = require('http');
var fs = require('fs');
var mime = require('mime');
http.createServer(function(req,res){
    if (req.url != '/app.js') {
    var url = __dirname + req.url;
        fs.stat(url,function(err,stat){
            if (err) {
            res.writeHead(404,{'Content-Type':'text/html'});
            res.end('Your requested URI('+req.url+') wasn\'t found on our server');
            } else {
            var type = mime.getType(url);
            var fileSize = stat.size;
            var range = req.headers.range;
                if (range) {
                    var parts = range.replace(/bytes=/, "").split("-");
                var start = parseInt(parts[0], 10);
                    var end = parts[1] ? parseInt(parts[1], 10) : fileSize-1;
                    var chunksize = (end-start)+1;
                    var file = fs.createReadStream(url, {start, end});
                    var head = {
                'Content-Range': `bytes ${start}-${end}/${fileSize}`,
                'Accept-Ranges': 'bytes',
                'Content-Length': chunksize,
                'Content-Type': type
                }
                    res.writeHead(206, head);
                    file.pipe(res);
                    } else {    
                    var head = {
                'Content-Length': fileSize,
                'Content-Type': type
                    }
                res.writeHead(200, head);
                fs.createReadStream(url).pipe(res);
                    }
            }
        });
    } else {
    res.writeHead(403,{'Content-Type':'text/html'});
    res.end('Sorry, access to that file is Forbidden');
    }
}).listen(8080);